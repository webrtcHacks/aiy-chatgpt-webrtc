<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>chatGPT Realtime Chat</title>
    <style>
        body {
            background: #222;
            color: #f9f9f9;
            font-family: Arial, sans-serif;
        }

        /* Log container styling */
        #log {
            border: 1px solid #444;
            padding: 10px;
            margin-top: 10px;
            height: 300px;
            overflow-y: auto;
            background: #333;
            color: #f9f9f9;
            display: flex;
            flex-direction: column;
        }

        .log-message {
            margin-bottom: 5px;
        }

        /* Input area styles as part of the log container */
        #inputContainer {
            margin-top: auto; /* push input area to the bottom */
            display: flex;
            align-items: center;
        }

        #textInput {
            flex: 1;
            padding: 8px;
            margin-right: 4px;
            background: #444;
            color: #f9f9f9;
            border: 1px solid #555;
        }

        Button {
            padding: 8px;
            background: #555;
            color: #f9f9f9;
            border: 1px solid #666;
        }

        /* Settings form styling */
        #settingsForm {
            display: none;
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #444;
            background: #333;
        }

        #settingsForm input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #444;
            color: #f9f9f9;
            border: 1px solid #555;
            box-sizing: border-box; /* Ensure padding and border are included in the element's total width */
        }

        #settingsForm button {
            padding: 8px;
            background: #555;
            color: #f9f9f9;
            border: 1px solid #666;
        }
    </style>
</head>
<body>
<h1>Chat with GPT-4 Realtime and WebRTC</h1>
<p>Press the physical button to start/end a session.</p>

<!-- Settings button -->
<button id="startButton">üîò Start Session</button>
<button id="endButton" hidden>üîò End Session</button>
<button id="settingsButton">‚öôÔ∏è Settings</button>

<!-- Settings form -->
<div id="settingsForm">
    <label for="openaiApiKey">OpenAI API Key: </label>
    <input id="openaiApiKey" type="text" placeholder="OpenAI API Key"
           value="Your OPENAI_API_KEY from platform.openai.com">
    <br>
    <label for="temperature">Temperature: </label>
    <input id="temperature" type="number" step="0.1" min="0" max="1" placeholder="Temperature" value="0.7"
           style="width: 60px">
    <br>
    <label for="voice">Select Voice: </label>
    <select id="voice">
        <option value="alloy" selected>Alloy</option>
        <option value="echo">Echo</option>
        <option value="shimmer">Shimmer</option>
        <option value="ash">Ash</option>
        <option value="ballad">Ballad</option>
        <option value="coral">Coral</option>
        <option value="sage">Sage</option>
        <option value="verse">Verse</option>
    </select>
    <br>

    <label for="sessionInstructions">Session instructions: </label>
    <input id="sessionInstructions" type="text" placeholder="Session instructions" value="You are a friendly assistant">
    <br>
    <label for="startInstructions">Start instructions: </label>
    <input id="startInstructions" type="text" placeholder="Start instructions"
           value="Greet the user and ask how you can help">
    <br>
    <button onclick="resetSettings()"> üîÑ Reset Settings</button>
    <span id="autoSaveStatus"></span>
</div>

<!-- Single container for both log messages and the input area -->
<div id="log">
    <div id="inputContainer">
        <label for="textInput"></label>
        <input id="textInput" type="text" placeholder="Type your message here">
        <button id="sendButton" onclick="sendText()">Send</button>
    </div>
</div>

<script>
    // Globals
    let ws; // websocket
    let pc; // peer connection
    let localTrack; // local audio track
    let dc;  // Only use the first opened data channel (because there are 2)
    const assistantResults = {}; // To track interim results by message ID
    let openaiApiKey; // OpenAI API Key
    const userMessages = {}; // To track user messages by item ID


    // Helper function to get element by ID
    const $ = (id) => document.getElementById(id);

    // Store elements in variables
    const keyEl = $("openaiApiKey");
    const sessionInstructionsEl = $("sessionInstructions");
    const startInstructionsEl = $("startInstructions");
    const temperatureEl = $("temperature");
    const voiceEl = $("voice");
    const startButtonEl = $("startButton");
    const endButtonEl = $("endButton");
    const autoSaveStatusEl = $("autoSaveStatus");
    const settingsButtonEl = $("settingsButton");
    const settingsFormEl = $("settingsForm");
    const logEl = $("log");
    const inputContainerEl = $("inputContainer");
    const textInputEl = $("textInput");
    const sendButtonEl = $("sendButton");

    // Default model inputs
    const model = "gpt-4o-mini-realtime-preview";
    const defaultKey = "Your OPENAI_API_KEY from platform.openai.com";
    const defaultSessionInstructions = "You are a friendly assistant";
    const defaultStartInstructions = "Greet the user and ask how you can help";
    const defaultEndInstructions = "Input is ending until the user presses the button again. " +
        "Give a quick good-bye. " +
        "Sometimes remind the user to press the button to start a new session."
    const defaultTemperature = 0.7;
    const defaultVoice = "alloy";
    const gptFunctions = [
        {
            type: "function",
            name: "end_session",
            description: "the user would like to stop interacting with the Agent " +
                "by saying something like 'goodbye' or 'stop'.",
            parameters: {},
        },
        {
            type: "function",
            name: "power_down",
            description: "Triggers a system power-down when the user wants to turn off the computer " +
                "by saying shut down, power off, turn off or similar phrases. " +
                "Always ask for confirmation before executing.",
            parameters: {}
        }
    ];

    /**
     * Append a new log entry to the log container.
     * @param {string} message - The message to append.
     * @param {string} className - The class name to add to the log entry.
     * @param {string} messageId - The ID of the message to update.
     */
    function appendOrUpdateLog(message, className = "", messageId = null) {
        let logEntry;
        if (messageId && $(messageId)) {
            // Update existing log entry
            logEntry = $(messageId);
            logEntry.textContent = message;
        } else {
            // Create a new log entry
            logEntry = document.createElement("div");
            logEntry.textContent = message;
            logEntry.classList.add("log-message");
            if (className) logEntry.classList.add(className);
            if (messageId) logEntry.id = messageId;
            // Insert the log entry before the input container so that the input stays at the bottom.
            logEl.insertBefore(logEntry, inputContainerEl);
        }
        // Auto-scroll to the bottom
        logEl.scrollTop = logEl.scrollHeight;
    }

    // Start a new session
    startButtonEl.addEventListener("click", async () => {
        if (pc) {
            console.log("Session already started");
            appendOrUpdateLog("Session already started.", "system-message");
            return;
        }
        startButtonEl.hidden = true;
        endButtonEl.hidden = false;
        await startSession();
    });

    // End the current session
    endButtonEl.addEventListener("click", async () => {
        if (!pc) {
            console.log("No session to end");
            appendOrUpdateLog("No session to end.", "system-message");
            return;
        }
        startButtonEl.hidden = false;
        endButtonEl.hidden = true;
        await endSession();
    });

    // Show/hide settings form
    settingsButtonEl.addEventListener("click", () => {
        settingsFormEl.style.display = settingsFormEl.style.display === "none" ? "block" : "none";
    });

    // Load settings from localStorage
    keyEl.value = localStorage.getItem("openaiApiKey") || defaultKey;
    sessionInstructionsEl.value = localStorage.getItem("sessionInstructions") || defaultSessionInstructions;
    startInstructionsEl.value = localStorage.getItem("startInstructions") || defaultStartInstructions;
    temperatureEl.value = localStorage.getItem("temperature") || defaultTemperature;
    voiceEl.value = localStorage.getItem("voice") || defaultVoice;

    /**
     * Autosave settings to localStorage.
     */
    function autoSaveSettings() {
        const settings = {
            openaiApiKey: keyEl.value,
            sessionInstructions: sessionInstructionsEl.value,
            startInstructions: startInstructionsEl.value,
            temperature: temperatureEl.value,
            voice: voiceEl.value
        };
        Object.entries(settings).forEach(([key, value]) => localStorage.setItem(key, value));
        sendNewSettings();
        autoSaveStatusEl.textContent = "Settings autosaved at " + new Date().toLocaleTimeString();
    }

    // Add event listeners to input fields to trigger autosave
    [keyEl, sessionInstructionsEl, startInstructionsEl, temperatureEl, voiceEl].forEach(el => {
        el.addEventListener("change", () => {
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(autoSaveSettings, 2000);
        });
    });


    /**
     * Reset settings to default values.
     */
    function resetSettings() {
        const settings = {
            sessionInstructions: sessionInstructionsEl.value,
            startInstructions: startInstructionsEl.value,
            temperature: temperatureEl.value,
            voice: voiceEl.value
        };
        Object.entries(settings).forEach(([key, value]) => localStorage.setItem(key, value));
        // update the UI
        loadSettings();
        sendNewSettings();
        console.log("Settings reset!");
    }

    /**
     * Send new settings to the GPT server.
     */
    function sendNewSettings() {
        if (dc && dc.readyState === "open") {
            // Update session instructions
            const message = {
                type: "session.update",
                session: {
                    instructions: sessionInstructionsEl.value,
                    // voice: voiceEl.value, // Cannot update a conversation's voice if assistant audio is present."
                    tools: gptFunctions,
                    tool_choice: "auto",
                    temperature: parseFloat(temperatureEl.value)
                }
            };
            dc.send(JSON.stringify(message));
            console.log("Sent message to GPT server:", message);
        } else {
            console.log("Data channel not open. Please wait until session starts.");
        }
    }

    /**
     * Load settings from localStorage.
     */
    function loadSettings() {
        const openaiApiKey = localStorage.getItem("openaiApiKey") || defaultKey;
        const sessionInstructions = localStorage.getItem("sessionInstructions") || defaultSessionInstructions;
        const startInstructions = localStorage.getItem("startInstructions") || defaultStartInstructions;
        const temperature = localStorage.getItem("temperature") || defaultTemperature;
        const voice = localStorage.getItem("voice") || defaultVoice;
        keyEl.value = openaiApiKey;
        sessionInstructionsEl.value = sessionInstructions;
        startInstructionsEl.value = startInstructions;
        temperatureEl.value = temperature;
        voiceEl.value = voice;
    }

    /**
     * Initialize a WebSocket connection to the server.
     */
    function initWebSocket() {
        ws = new WebSocket('ws://' + window.location.host + '/ws');
        ws.onopen = () => {
            console.log("WebSocket connected to server");
            ws.send(JSON.stringify({type: "page_loaded"}));
        };

        // Route handler for messages from the server
        ws.onmessage = async (event) => {
            const msg = JSON.parse(event.data);
            if (msg.type === "button_press") {
                if (!pc) {
                    // No active session - start one
                    startButtonEl.hidden = true;
                    endButtonEl.hidden = false;
                    await startSession();
                } else {
                    // Active session - end it
                    startButtonEl.hidden = false;
                    endButtonEl.hidden = true;
                    await endSession();
                }
            } else {
                console.log("Unknown message:", msg);
            }
        };
        ws.onerror = (err) => {
            console.error("WebSocket error:", err);
        };
        ws.onclose = () => {
            console.log("WebSocket closed");
        };
    }

    /**
     * Handle data channel messages from the GPT server.
     * @param {Object} event - The datachannel message event
     */
    function handleMessage(event) {
        const message = JSON.parse(event.data);
        console.info("Message from GPT server:", message);
        const itemId = message.item_id;

        switch (message.type) {
            case "input_audio_buffer.speech_started":
                userMessages[itemId] = {message: ""};
                appendOrUpdateLog(`User: ...`, "user-message", itemId);
                break;

            case "conversation.item.input_audio_transcription.completed":
                const content = message.transcript;
                if (content && userMessages[itemId]) {
                    userMessages[itemId].message = content;
                    appendOrUpdateLog(`User: ${content}`, "user-message", itemId);
                }
                break;

            case "response.audio_transcript.delta":
                if (itemId) {
                    assistantResults[itemId] = assistantResults[itemId] || "";
                    assistantResults[itemId] += message.delta;
                    appendOrUpdateLog(`Assistant (interim): ${assistantResults[itemId]}`, "interim-result", itemId);
                }
                break;

            case "response.audio_transcript.done":
                if (itemId) {
                    assistantResults[itemId] = message.transcript;
                    appendOrUpdateLog(`Assistant: ${message.transcript}`, "agent-message", itemId);
                }
                break;

            case "response.function_call_arguments.done":
                const {name} = message;
                switch (name) {
                    case "end_session":
                        console.log("User confirmed end session");
                        ws.send(JSON.stringify({type: "end_session"}));
                        endSession();
                        break;

                    case "power_down":
                        console.log("User confirmed power down");
                        ws.send(JSON.stringify({type: "power_down"}));
                        endSession("Tell the user they will need to turn the system back on start a new chat. ");
                        break;
                }
                break;

            case "output_audio_buffer.audio_stopped":
                console.log("Final audio stopped");
                endSession();
                break;

            // default:
            //     console.log("Unhandled message:", message);
        }
    }

    /**
     * Fetch an ephemeral key from OpenAI to start a Realtime session.
     * @returns {Promise<*|null>}
     */
    async function fetchEphemeralKey(openaiApiKey) {
        const headers = {
            "Authorization": `Bearer ${openaiApiKey}`,
            "Content-Type": "application/json"
        };
        const payload = {
            model: model,
            voice: voiceEl.value,
            input_audio_format: "pcm16",
            input_audio_transcription: {model: "whisper-1"},
            instructions: sessionInstructionsEl.value
        };

        try {
            const response = await fetch("https://api.openai.com/v1/realtime/sessions", {
                method: "POST",
                headers: headers,
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                console.error("Failed to create ephemeral session:", await response.text());
                return null;
            }

            const data = await response.json();
            const key = data?.client_secret?.value;
            if (!key) {
                console.error("Invalid response format: missing client_secret.value", data);
                return null;
            } else {
                console.log("Received ephemeral key:", key);
                return key;
            }
        } catch (error) {
            console.error("Error fetching ephemeral key:", error);
            return null;
        }
    }

    /**
     * Start a new Realtime session with the OpenAI realtime WebRTC API.
     */
    async function startSession() {

        console.log("start_session");
        startButtonEl.disabled = true;

        const openaiApiKey = keyEl.value;
        // Make sure the key is populated
        if (openaiApiKey === defaultKey || openaiApiKey === "") {
            console.error("No OpenAI API Key provided");
            appendOrUpdateLog("Error: No OpenAI API Key provided.", "system-message");
            return
        }

        const ephemeralKey = await fetchEphemeralKey(openaiApiKey);

        if (!ephemeralKey) {
            startButtonEl.hidden = false;
            endButtonEl.hidden = true;
            return;
        }

        try {
            // Create PeerConnection
            pc = new RTCPeerConnection();

            // Remote audio element
            const audioEl = document.createElement("audio");
            audioEl.autoplay = true;
            document.body.appendChild(audioEl);
            pc.ontrack = (e) => {
                audioEl.srcObject = e.streams[0];
            };

            // Local microphone stream
            const stream = await navigator.mediaDevices.getUserMedia({audio: true})
                .catch(err => {
                    console.error("Error accessing microphone:", err);
                    appendOrUpdateLog("Error accessing microphone. Please allow microphone access.", "system-message");
                    startButtonEl.disabled = false;
                    startButtonEl.hidden = false;
                    endButtonEl.hidden = true;
                });
            localTrack = stream.getTracks()[0];
            pc.addTrack(localTrack);

            // Data channel: only open once
            if (!dc) {
                dc = pc.createDataChannel("oai-events");
                dc.addEventListener("message", handleMessage);
            } else {
                console.log("datachannel already exists", dc);
            }

            dc.onopen = () => {
                const sessionInstructions = localStorage.getItem("sessionInstructions") || defaultSessionInstructions;
                const startInstructions = localStorage.getItem("startInstructions") || defaultStartInstructions;
                const temperature = parseFloat(localStorage.getItem("temperature")) || defaultTemperature;

                const systemMessage = {
                    type: "session.update",
                    session: {
                        instructions: sessionInstructions,
                        tools: gptFunctions,
                        tool_choice: "auto",
                    }
                };
                dc.send(JSON.stringify(systemMessage));

                const startMessage = {
                    type: "response.create",
                    response: {
                        modalities: ["text", "audio"],
                        instructions: startInstructions,
                        temperature: temperature,
                        max_output_tokens: 100
                    }
                };
                dc.send(JSON.stringify(startMessage));
                console.log("Sent message to GPT server:", startMessage);
                appendOrUpdateLog("Session started.", "system-message");
            };

            // Create and send offer to OpenAI
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            const baseUrl = "https://api.openai.com/v1/realtime";
            const sdpResp = await fetch(`${baseUrl}?model=${model}`, {
                method: "POST",
                body: offer.sdp,
                headers: {
                    Authorization: `Bearer ${ephemeralKey}`,
                    "Content-Type": "application/sdp"
                },
            });
            if (!sdpResp.ok) {
                console.error(new Error("Failed to fetch SDP answer from OpenAI"));
            }
            const answer = {type: "answer", sdp: await sdpResp.text()};
            await pc.setRemoteDescription(answer);

            startButtonEl.disabled = false;
            startButtonEl.hidden = true;
            endButtonEl.hidden = false;

            console.log("Realtime session started!");

        } catch (err) {
            console.error("Error starting session:", err);
            appendOrUpdateLog("Error starting session. Please try again.", "system-message");
            if (pc) {
                pc.close();
                pc = null;
                dc = null;
            }
            startButtonEl.disabled = false;
            startButtonEl.hidden = false;
            endButtonEl.hidden = true;
        }
    }

    /**
     * End the current Realtime session.
     * @param {string} instructions - Instructions to send to the GPT model.
     */
    async function endSession(instructions) {
        // Schedule session end after 12 seconds
        console.log("Ending session...");

        const message = {
            type: "response.create",
            response: {
                modalities: ["text", "audio"],
                instructions: instructions || defaultEndInstructions,
                temperature: parseFloat(temperatureEl.value),
                max_output_tokens: 50
            }
        };
        dc.send(JSON.stringify(message));

        // Turn-off mic input
        if (localTrack) {
            localTrack.stop();
            localTrack = null;
        }

        endButtonEl.disabled = true;

        // ToDo: Wait for the response to finish from the model before closing the session.
        setTimeout(() => () => {
            if (pc) {
                pc.close();
                pc = null;
                dc = null;
            }
            console.log("Session ended.");
            appendOrUpdateLog("Session ended.", "system-message");

            startButtonEl.disabled = false;
            startButtonEl.hidden = false;
            endButtonEl.hidden = true;

        }, 12_000);
    }

    /**
     * Send the text message from the input field to the GPT model.
     */
    function sendText() {
        const text = textInputEl.value.trim();
        if (!text) return;
        if (dc && dc.readyState === "open") {
            const message = {
                type: "response.create",
                response: {
                    modalities: ["text", "audio"],
                    instructions: text,
                    temperature: parseFloat(temperatureEl.value),
                    max_output_tokens: 500
                }
            };
            dc.send(JSON.stringify(message));
            appendOrUpdateLog("User (text): " + text, "user-message");
            textInputEl.value = "";
        } else {
            appendOrUpdateLog("Data channel not open. Please wait until session starts.", "system-message");
        }
    }

    sendButtonEl.addEventListener("click", sendText);

    // Add event listener for Enter key press in textInput
    textInputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
            sendText();
        }
    });

    // Initialize WebSocket when the window loads
    window.addEventListener("load", () => {
        loadSettings();
        initWebSocket();
    });
</script>
</body>
</html>