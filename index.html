<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Realtime Chat w/ websockets</title>
</head>
<body>
  <h1>Realtime Chat with GPT-4</h1>
  <p>Press the physical button to start/end a session.</p>

  <script>
    let ws;
    let pc;
    let localTrack;
    let dc;           // only use the first opened data channel (because there are 2)

    function initWebSocket() {
      ws = new WebSocket(`ws://${window.location.hostname}:3001`);
      ws.onopen = () => {
        console.log("WebSocket connected to server");
        ws.send(JSON.stringify({ type: "page_loaded" }));
      };
      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === "start_session") {
          console.log("Received start_session from server");
          if(msg.ephemeralKey)
            await startSession(msg.ephemeralKey);
            else {
              console.error("No ephemeral key received from server");
              // ToDo: send error message to server
            }
        } else if (msg.type === "end_session") {
          console.log("Received end_session from server");
          await endSession();
        } else {
          console.log("Unknown message:", msg);
        }
      };
      ws.onerror = (err) => {
        console.error("WebSocket error:", err);
      };
      ws.onclose = () => {
        console.log("WebSocket closed");
      };
    }

    async function startSession(ephemeralKey) {
      try {
        // Create PeerConnection
        pc = new RTCPeerConnection();

        // Remote audio
        const audioEl = document.createElement("audio");
        audioEl.autoplay = true;
        document.body.appendChild(audioEl);
        pc.ontrack = (e) => {
          audioEl.srcObject = e.streams[0];
        };

        // Local mic
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        localTrack = stream.getTracks()[0];
        pc.addTrack(localTrack);

        // Data channel - only open once
        if(!dc)
          dc = pc.createDataChannel("oai-events");
        dc.addEventListener("message", (e) => {
          console.info("Message from GPT server:", e.data);
        });

        dc.onopen = () => {
          // wait 5 seconds before sending the first message
          // await new Promise((resolve) => setTimeout(resolve, 5000));

          const open_instructions = "Greet Neev by name, occasionally using a gen-Alpha style.";

          const message = {
            "event_id": "event_234",
            "type": "response.create",
            "response": {
            "modalities": ["text", "audio"],
                "instructions": open_instructions,
                "temperature": 0.8,
                "max_output_tokens": 1024
            }
          }
          dc.send(JSON.stringify(message));
          console.log("Sent message to GPT server:", message);
        };


        // Offer/Answer with OpenAI
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = "https://api.openai.com/v1/realtime";
        const model = "gpt-4o-realtime-preview-2024-12-17";
        const sdpResp = await fetch(`${baseUrl}?model=${model}`, {
          method: "POST",
          body: offer.sdp,
          headers: {
            Authorization: `Bearer ${ephemeralKey}`,
            "Content-Type": "application/sdp"
          },
        });
        if (!sdpResp.ok) {
          throw new Error("Failed to fetch SDP answer from OpenAI");
        }
        const answer = { type: "answer", sdp: await sdpResp.text() };
        await pc.setRemoteDescription(answer);

        // Optional chime
        const startedSound = new Audio("Chord2_Rev.wav");
        await startedSound.play();

        console.log("Realtime session started!");

        window.send = dc.send;

      } catch (err) {
        console.error("Error starting session:", err);
      }
    }

    async function endSession() {
      const message = {
            "event_id": "event_234",
            "type": "response.create",
            "response": {
            "modalities": ["text", "audio"],
                "instructions": "Input is ending until the user pressed the button again. " +
                        "Give a quick response to this.",
                "temperature": 0.6,
                "max_output_tokens": 1024
            }
          }
      dc.send(JSON.stringify(message));
      await new Promise((resolve) => setTimeout(resolve, 5000));
      console.log("Ending session...");
      if (pc) {
        pc.close();
        pc = null;
      }
      if (localTrack) {
        localTrack.stop();
        localTrack = null;
      }
      console.log("Session ended (client side).");
    }

    // Initialize
    window.addEventListener("load", () => {
      initWebSocket();
    });
  </script>
</body>
</html>